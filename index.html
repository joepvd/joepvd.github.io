<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>escape code</title>
    <link rel="stylesheet" href="http://joepvd.github.io/theme/css/main.css">
          <link href="http://joepvd.github.io/all.atom" type="application/atom+xml" rel="alternate" title="escape code Atom Feed" />
          </head>

  <body>
    <header> 
      <a href="http://joepvd.github.io/index.html" id=header>
        <h1>
          escape code         </h1>
      </a>
      <nav>
                  <a class=nav href="http://joepvd.github.io/archives.html">Archives</a>
                            <a class=nav href="http://joepvd.github.io/pages/about-this-website.html">About this website</a>
                        </nav>
    </header>

            
  <section id="content" class="body">

                  
        <article>
          <a class="title" href="http://joepvd.github.io/less-a-love-story.html">
            <h2>less: a love story</h2>
            <p class=sub-header>
              joepd, 2013-12-27
                          </p>
          </a> <!-- /"article-title --> 
          <p>Less. I use it more and more.  I would not be surprised if at least a fourth of my time in a console window actually is spent within less.  It is just a pager, you say?  True, but one that has been in <a class="reference external" href="http://www.greenwoodsoftware.com/less/index.html">active development</a> since 1983. The original developer currently is still the maintainer.  You don't need to be an experimental archeologist to put this tool to use. Getting acquainted to this pager will pay itself off pretty fast.</p>
<p>If you haven't done so yet, have a look at <tt class="docutils literal">man 1 less</tt>. The synopsis looks like Sesamestreet episode with brain damage:</p>
<pre class="code sh literal-block">
less <span class="o">[</span>-<span class="o">[</span>+<span class="o">]</span>aABcCdeEfFgGiIJKLmMnNqQrRsSuUVwWX~<span class="o">]</span>
</pre>
<p>It might appear that this overabundance of seemingly unneeded features could serve as a practical definition of bloatware.  These are just the options without arguments. Most of the same options can be used from within the application itself. Once you notice that you like some options, you can make those default.  There are some true gems hidden in the following alphabet soup from the synopsis. I will show which ones I regularly use, but only after having a close look at the searching capabilities of less.</p>
<p>Effective use of less implies that one can use its searching possibilities.  Striking the <tt class="docutils literal">/</tt> initiates a search, and <tt class="docutils literal">enter</tt> concludes it.  Use <tt class="docutils literal">n</tt> to go to the next match, <tt class="docutils literal">N</tt> for the previous.  Searching backward is started off with <tt class="docutils literal">?</tt>.</p>
<p>Search handles by default regular expressions.  With some terminal escape codes set up, less will highlight the matches.  I often type a string like this as a make-shift highlighter:</p>
<pre class="code sh literal-block">
/someID<span class="o">=[</span>0-9<span class="o">]</span>+|error|<span class="o">(</span>STATE|button<span class="o">)</span>.*<span class="err">$</span>
</pre>
<p>Less stores the searches in <tt class="docutils literal"><span class="pre">~/.lesshist</span></tt>, or in any file indicated by the environment variable <tt class="docutils literal">$LESSHISTFILE</tt>.  After starting typing <tt class="docutils literal">/</tt>, the up and down arrows are available to use previous searches.</p>
<p>A search can also be started from the shell.  When I already know what to look for, I often use this, also to leave traces of what I am interested in in the shell history.  Chances are that I already used this search term in the shell, or will in the near future.  Next to helping myself to use zsh's history completion feature, this has proven to be a real time saver when I need to revisit the same problem again.  A typical use is when I want to know what happened at a specific time:</p>
<pre class="code console literal-block">
<span class="gp">%</span> less +/^16:34 logfile
</pre>
<p>This will open the file, and jump immediately to the first line with that time stamp.  Less will also store this search in its history file.  Unfortunatelty, there is no mechanism to search the past searches.</p>
<p>The most recent search term has a special role when pressing <tt class="docutils literal"><span class="pre">ESC-F</span></tt>.  New content of the file will be displayed as with <tt class="docutils literal">tail <span class="pre">-f</span></tt> or the normal <tt class="docutils literal">F</tt>-function, but the scrolling will stop with the first match of the most recent search.</p>
<p>A lesser known search facility is the one initiated by <tt class="docutils literal">&amp;</tt>. This filters the output to just the matching lines.  I use this often when looking at the output of some command:  One can refrain from running the command again only to use grep to find the interesting lines.  A renewed search is done on the whole output, so one cannot apply a filter on a filter.  Specifying lines that do not match the expression (<tt class="docutils literal">grep <span class="pre">-v</span></tt>), can be initiated by typing <tt class="docutils literal">&amp;!</tt>.  After having refined the search pattern, the result can be saved with <tt class="docutils literal">s filename</tt>.</p>
<p>The <tt class="docutils literal">&amp;</tt>-filter interacts with the search history.  As I regularly have to dig in a logfiles where the first encounter is really helped by such a filter, I set up an alias like this:</p>
<pre class="code sh literal-block">
<span class="nb">alias </span><span class="nv">lf</span><span class="o">=</span><span class="s2">&quot;less +$'&amp;event1|action2|state3|error\n' &quot;</span>
</pre>
<p>With this less-filter I can quickly get a birds eye perspective on the events.  The filter can be disabled by an empty filter, so by pressing <tt class="docutils literal">&amp;[enter]</tt>. and can easily zoom in, and have this search string ready for poor man's highlighting.  A quick <tt class="docutils literal"><span class="pre">-N</span></tt> to display line numbers, and typing the number of where I want to start to look, followed by <tt class="docutils literal">g</tt>, brings me immediately to where I want to be.</p>
<p>When less is running, the following keys I use most:</p>
<dl class="docutils">
<dt>G</dt>
<dd>Go to end of file. Before that, check if the file has changed. Great for viewing log files.</dd>
<dt>g</dt>
<dd>Go to beginning of file, or, when a number is pressed first, go to that line number.</dd>
<dt>ESC-u</dt>
<dd>Undo search highlighting.</dd>
<dt>F</dt>
<dd>Follow file. It's like <tt class="docutils literal">tail <span class="pre">-f</span></tt>, but after the BREAK signal (CTRL+c), all the niceties of the pager are still intact.  And: <tt class="docutils literal">tail <span class="pre">-f</span></tt> cannot do the line wrapping.</dd>
<dt>Number%</dt>
<dd>Type in <tt class="docutils literal">50%</tt>, and you'll see the middle of the file.</dd>
<dt>-S[Enter]</dt>
<dd>Toggle line wrapping.</dd>
<dt>-i[Enter]</dt>
<dd>Toggle case insensitive search.</dd>
<dt>-N and -n</dt>
<dd>Enable and disable line numbers.</dd>
</dl>
<p>Despite the numerous options, I am not using so much more in my day to day usage of less.  Some options can be specified on the command line.  The following I consider nice:</p>
<dl class="docutils">
<dt>-R</dt>
<dd>For when the file contains raw characters, for example ANSI color codes. This causes less not to choke on colored output, or to see the garbage in a binary file, instead of an error message.</dd>
<dt>-X</dt>
<dd><p class="first">This causes the screen not to be repainted after less exits. After viewing a file or man-page, I find it increadibly useful to be able to see the last screen in my terminal emulator's scroll back window.  Just make the part visible that is of interest, and you have the reference visible when typing your command.  In most terminal emulators, Shift+PgUp/PgDown gets the relevant info back again.</p>
<p>This setting makes most sense when the output is not too long, or if you know you'll be able to get to the important points in few jumps.  To disable this feature, use <tt class="docutils literal"><span class="pre">-+X</span></tt> as an option.</p>
<p class="last">It is unfortunate that everything that has been displayed in less is retained in the scrollback. It would be more convenient to only have a screen full of output in the console, especially when needing to browse insane amounts of text.  I have not yet managed to fix this.</p>
</dd>
<dt>-M</dt>
<dd>Get a long prompt in less. Useful info about filename, length of file, and current position.</dd>
</dl>
<p>To have less always use the same options that you like, it listens to the <tt class="docutils literal">$LESS</tt> environment variable in your <tt class="docutils literal"><span class="pre">~/.bashrc</span></tt> or <tt class="docutils literal"><span class="pre">$ZDOTDIR/.zshrc</span></tt>.  I have set mine to the following:</p>
<pre class="code sh literal-block">
<span class="nb">export </span><span class="nv">LESS</span><span class="o">=</span><span class="s1">'MSRiX'</span>
</pre>
<p>These letters have the following effect: long prompt, chop long lines, raw, case insensitive search, keep output in scrollback buffer.</p>
<p>Possibly, your distribution, or you yourself, has set up some nice colors to display different colors in man-pages.  I have the following escape codes somewhere in the startup files of my shell:</p>
<pre class="code sh literal-block">
<span class="nb">export </span><span class="nv">LESS_TERMCAP_mb</span><span class="o">=</span><span class="s1">$'\e[01;31m'</span>       <span class="c"># begin blinking
</span><span class="nb">export </span><span class="nv">LESS_TERMCAP_md</span><span class="o">=</span><span class="s1">$'\e[01;38;5;74m'</span>  <span class="c"># begin bold
</span><span class="nb">export </span><span class="nv">LESS_TERMCAP_me</span><span class="o">=</span><span class="s1">$'\e[0m'</span>           <span class="c"># end mode
</span><span class="nb">export </span><span class="nv">LESS_TERMCAP_so</span><span class="o">=</span><span class="s1">$'\e[38;5;070m'</span>    <span class="c"># begin standout (info box, search)
</span><span class="nb">export </span><span class="nv">LESS_TERMCAP_se</span><span class="o">=</span><span class="s1">$'\e[0m'</span>           <span class="c"># end standout-mode
</span><span class="nb">export </span><span class="nv">LESS_TERMCAP_us</span><span class="o">=</span><span class="s1">$'\e[04;38;5;146m'</span> <span class="c"># begin underline
</span><span class="nb">export </span><span class="nv">LESS_TERMCAP_ue</span><span class="o">=</span><span class="s1">$'\e[0m'</span>           <span class="c"># end underline
</span><span class="nb">export </span><span class="nv">MAN_KEEP_FORMATTING</span><span class="o">=</span>1
</pre>
<p>The last entry might not be clear.  When piping the output of <tt class="docutils literal">man</tt> to less, the colors are not retained. Unless the <tt class="docutils literal">MAN_KEEP_FORMATTING</tt> environment variable has a value.</p>
<p>The same trick I use in Something that I often use if I want to see : <tt class="docutils literal">man less | less <span class="pre">+/'^</span> <span class="pre">*-X'</span></tt>. This jumps directly to the place where <tt class="docutils literal"><span class="pre">-X</span></tt> is in front of a line, possibly with some spaces. Most of the time, it just jumps to the explanation that you want to see, otherwise press <tt class="docutils literal">n</tt> to jump to the next hit.</p>

        </article>
                                
        <article>
          <a class="title" href="http://joepvd.github.io/parameter-expansion-in-zsh.html">
            <h2>Parameter expansion in zsh</h2>
            <p class=sub-header>
              joepd, 2013-12-10
                          </p>
          </a> <!-- /"article-title --> 
          <p>The shell is a high quality text processor, and zsh is especially suited for that purpose.  In this post, I will show some of the tricks I use for an editing problem that I encounter every day.  Concretely: How to quickly generate queries, after receiving a list of IDs.  This is what the result should look like:</p>
<pre class="code sql literal-block">
<span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="k">table</span> <span class="k">where</span> <span class="n">ID</span> <span class="k">in</span> <span class="p">(</span><span class="s1">'1234'</span><span class="p">,</span> <span class="s1">'2345'</span><span class="p">,</span> <span class="s1">'3456'</span><span class="p">);</span>
</pre>
<p>A fast way to achieve this looks thusly:</p>
<pre class="code console literal-block">
<span class="gp">%</span> <span class="nv">ar</span><span class="o">=(</span>
<span class="go">array&gt; 1234
array&gt; 2345
array&gt; 3456
array&gt; )

</span><span class="gp">%</span> print <span class="s2">&quot;select * from table where id in (${(j:, :)${(qq)ar[&#64;]}});&quot;</span>
<span class="go">select * from table where id in ('1234', '2345', '3456');</span>
</pre>
<p>What is happening here? First I am creating an array of something I have available in my paste buffer: I type the name of an array, <cite>=</cite>, and <cite>(</cite>, and press enter. Then I paste a list of IDs, close it off with a <cite>)</cite>. Now the info is available at my fingertips. The second action, the print statement with the hardly memorable parameter expansion, is the main topic of this post.</p>
<p>Shells provide convenience functions to do stuff with parameters, and <cite>zsh</cite> surely is the most advanced in this regard.  These parameter expansions are easiest to read from the inside to the outside, so let's have a look at <tt class="docutils literal"><span class="pre">${(qq)ar[&#64;]}</span></tt>.  This consists of two parts, <tt class="docutils literal"><span class="pre">${ar[&#64;]}</span></tt> and <tt class="docutils literal">(qq)</tt>.</p>
<p>The result of <tt class="docutils literal"><span class="pre">${ar[&#64;]}</span></tt> is into all the elements of array <tt class="docutils literal">ar</tt>.  In any shell that conforms to POSIX, you can specify elements of an array by encapsulating them in square brackets: <tt class="docutils literal">${ar[2]}</tt> would be <tt class="docutils literal">2345</tt>.  One can use the <tt class="docutils literal">&#64;</tt> to say that you want all the indexes.</p>
<p>In <tt class="docutils literal">zsh</tt>, if there is an opening bracket directly after the curly opening bracket, magic is immanent.  The bracketed characters are flags.  For a complete overview of what can be done, see <tt class="docutils literal">man zshexpn | less <span class="pre">+/'^</span> *Parameter Expansion Flags'</tt>. In this case, the members of <tt class="docutils literal">ar</tt> are treated with the action that is hiding behind the <tt class="docutils literal">qq</tt>.  The effect of this flag is quoted with single quotes.  (You can use three q's for double quotes).</p>
<p>So the net result of the inner expansion is a copy of the arrat <tt class="docutils literal">ar</tt>, with the difference that the elements are quoted.  This is the intermediate result what the outer expansion, <tt class="docutils literal"><span class="pre">${(j:,</span> <span class="pre">:)…}</span></tt> is working with.  The flag <tt class="docutils literal">j</tt> is for joining the elements of an array, with whatever is between the colons as a separator, in our case a comma followed by space. The colons are arbitrary: If your join string contains colons itself, you can take a comma or a period, or whatever.</p>
<p>The result is, as you have seen, that <tt class="docutils literal"><span class="pre">${(j:,</span> <span class="pre">:)${(qq)ar[&#64;]}}</span></tt> is expanded to a comma separated line of quoted elements of array <tt class="docutils literal">ar</tt>.  As I use this kind of expansion on a daily basis, and this expansion is a bit too tedious to type in every time, I spent a bit of time to make this expansion available at my finger tips in the form of a shell function <tt class="docutils literal">a2q</tt>:</p>
<pre class="code sh literal-block">
a2q <span class="o">()</span> <span class="o">{</span>
        print <span class="k">${</span><span class="p">(j:, :)</span><span class="k">${</span><span class="p">(Pqq)1</span><span class="k">}</span><span class="p">[&#64;]</span><span class="k">}</span>
<span class="o">}</span>
</pre>
<p>This can be used as follows:</p>
<pre class="code console literal-block">
<span class="gp">%</span> print <span class="s2">&quot;select * from table where id in ($(a2q ar));&quot;</span>
</pre>
<p>Compared to the interactive version, the array is a positional parameter: <tt class="docutils literal">$1</tt> is being expanded, so you can type: <tt class="docutils literal">a2q myarray</tt> to have <tt class="docutils literal">a2q</tt> work on <tt class="docutils literal">myarray</tt>. In order to make this work, an extra trick needed to be added:  The <cite>P</cite>-flag has been added to the inner parameter expansion flags. This makes that the resulting string is considered to be a parameter.</p>
<p>This works great, but it can be generalized.  Sometimes the list of IDs is given as an file.  By virtue of the <cite>f</cite>-flag, the following snippet loads the newline separated contents of file <cite>file</cite> into array <cite>array</cite>:</p>
<pre class="code sh literal-block">
<span class="nv">array</span><span class="o">=(</span> <span class="k">${</span><span class="p">(f)</span><span class="k">$(</span>&lt;file<span class="k">)}</span> <span class="o">)</span>
</pre>
<p>Just to facilitate laziness, the function a2q can be expanded to check what type of argument it got, and based on that, populate a temporary array with infos. Multiple arguments are allowed. If no argument is provided, a2q will listen to STDIN, so you can pipe the output of another command to it. After all the processing, the last step is to print the contents of the array in the desired way:</p>
<pre class="code sh literal-block">
emulate -L zsh
<span class="nb">typeset</span> -U ar
<span class="nv">ar</span><span class="o">=()</span>
_err<span class="o">()</span> <span class="o">{</span>
    <span class="nb">echo</span> <span class="s2">&quot;Do not understand: ${1}&quot;</span> &gt;&amp;2
    <span class="nb">echo</span> <span class="s2">&quot;Arguments need to be files, names of arrays, or standard input.&quot;</span> &gt;&amp;2
    <span class="nb">echo</span> <span class="s1">'Arrays must be referenced by name, so use `array` instead of `$array`.'</span> &gt;&amp;2
    <span class="nb">exit </span>1
<span class="o">}</span>

<span class="k">if</span> <span class="o">[[</span> <span class="nv">$# </span><span class="o">==</span> 0 <span class="o">]]</span>; <span class="k">then</span>
    <span class="c"># Listen to STDIN if no arguments are provided
</span>    <span class="nv">ar</span><span class="o">=(</span> <span class="k">${</span><span class="p">(f)</span><span class="k">$(</span>&lt;&amp;0<span class="k">)}</span> <span class="o">)</span>
<span class="k">fi

while</span> <span class="o">[[</span> <span class="nv">$# </span>&gt; 0 <span class="o">]]</span>; <span class="k">do
    if</span> <span class="o">[[</span> -r <span class="s2">&quot;$1&quot;</span> <span class="o">&amp;&amp;</span> -f <span class="s2">&quot;$1&quot;</span> <span class="o">]]</span>; <span class="k">then</span>
        <span class="c"># A readable file.
</span>        <span class="nv">ar</span><span class="o">=(</span>
            <span class="nv">$ar</span><span class="o">[</span>&#64;<span class="o">]</span>
            <span class="s2">&quot;${(fq)$(&lt;$1)}&quot;</span>
        <span class="o">)</span>
    <span class="k">elif</span> <span class="o">[[</span> <span class="k">${</span><span class="p">(Pt)1</span><span class="k">}</span> <span class="o">=</span> <span class="s2">&quot;array&quot;</span> <span class="o">]]</span>; <span class="k">then
        </span><span class="nv">ar</span><span class="o">=(</span>
            <span class="nv">$ar</span><span class="o">[</span>&#64;<span class="o">]</span>
            <span class="k">${</span><span class="p">(Pq)1</span><span class="k">}</span>
        <span class="o">)</span>
    <span class="k">else
        </span>_err
    <span class="k">fi
    </span><span class="nb">shift
</span><span class="k">done

</span>print <span class="k">${</span><span class="p">(j:, :)</span><span class="k">${</span><span class="p">(qq)ar[&#64;]</span><span class="k">}}</span>
</pre>
<p>I stored the above as <tt class="docutils literal">a2q</tt> in a <a class="reference external" href="http://zsh.sourceforge.net/Doc/Release/Functions.html#Autoloading-Functions">directory whose contents gets autoloaded</a> when required, so I have it available at my finger tips.</p>
<p>Enjoy!</p>

        </article>
                                
        <article>
          <a class="title" href="http://joepvd.github.io/about-this-website.html">
            <h2>About this website</h2>
            <p class=sub-header>
              joepd, 2013-12-09
                          </p>
          </a> <!-- /"article-title --> 
          <p>Hello world! This is the first post to my site, which will double as the about page.  Yet another site dedicated to consoles, shells, and old school interfaces to solved problems?  Isn't there enough documentation and experience out there to warrant another site?</p>
<p>As with all good questions, the answer is both <em>yes</em> and <em>no</em>.</p>
<p><strong>Yes</strong>.  I proudly want to produce new content as a tribute to all the valuable and intricate pieces of information that have been shared before.  I have learnt an awful lot from excellent people documenting informally how they overcome smaller and bigger technological hurdles while accomplishing stuff.  And I have enjoyed doing so.  A second reason for this resounding yes, is the hope that processes of documenting and publishing trivia, intricacies and insights will assist me in the battle against forgetfulness.</p>
<p>But I fancy to think that also that also <strong>No</strong> is a valid answer:  This site will have a distinctive perspective.  One thing where I find current informal, online documentation lacking, is in the description of <strong>interactive usage</strong> of tools.  Much of the online documentation is a static description of how tools work, whereas how those tools can be used efficiently in a work flow of analyzing and fixing problems.  If this were a blog about cooking, I would try to refrain from showing the ingredients and knives, and rather focus on how to cut and fry an onion to acchieve different results.</p>
<p>I have a fetish for basic tools.  Be it a sharp knife in the kitchen, or the precise power tools that the One Thing Well software philosophy has brought about.  The process of interactive discovery of the real problem is where the flexibility of the software tool philosophy really shines.  In this blog I hope to provide some useful perspectives, approaches and recipes about the intersection of basic tools and work flows.</p>
<p>This site is statically generated with <a class="reference external" href="http://getpelican.com">Pelican</a>, and I don't feel the need to take care of comments.  I do not want to imply that I do not like feed back, but prefer to get spam in my mail box rather than on the public net that I need to maintain.  For now, for praise and bug reports, you can reach me best over email. I am sure you can puzzle my address together from the following bits of information:</p>
<p>user: escape-code
host: xs4all
tld: nl</p>
<p>Enjoy reading!</p>

        </article>
                              </section>

    <footer>
      <address id="about" class="vcard body">
        Powered by <a href="http://getpelican.com/">Pelican</a>. 
      </address><!-- /#about -->

      <p>
      All rights reserved. All wrongs reversed. All is released in the public
      domain. 
      </p>
    </footer>
  </body>
</html>