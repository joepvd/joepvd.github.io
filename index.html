<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>escape code</title>
    <link rel="stylesheet" href="http://joepvd.github.io/theme/css/main.css">
      <link href="http://joepvd.github.io/all.atom" type="application/atom+xml" rel="alternate" title="escape code Atom Feed" />
  </head>

  <body>
    <header> 
      <a href="http://joepvd.github.io/index.html" id=header>
        <h1>
          escape code         </h1>
      </a>
      <nav>
          <a class=nav href="http://joepvd.github.io/archives.html">Archives</a>
            <a class=nav href="http://joepvd.github.io/pages/about-this-website.html">About this website</a>
          <a href="http://joepvd.github.io/all.atom"
            type="application/atom+xml" rel="alternate" title="escape code
            Atom Feed">
            <img 
              src="http://joepvd.github.io/theme/images/icons/rss.png"
              alt="Atom feed" 
              width="20px"
              height="20px"
            />
          </a>
      </nav>
    </header>

        
  <section id="content" class="body">

        
        <article>
          <a class="title" href="http://joepvd.github.io/zsh-learn-while-doing.html">
            <h2>zsh: learn while doing</h2>
            <p class=sub-header>
              joepd, 17 April 2014
            </p>
          </a> <!-- /"article-title --> 
          <p>What good are advanced and hard to remember features if there is no help available at a fingertip?  Globbing in zsh might be the best thing since sliced bread, but if you don't know the details, you might as well be chewing on a brick.</p>
<p>So, why not organize in such a way so that the details are readily available?  One of the many nice ideas from feh's <a class="reference external" href="http://git.plenz.com/configs/plain/.zsh/zshrc">excellent zsh configuration file</a> does exactly that, but it looked ugly on a too small terminal, and it looks like quite some manual work to format the information in <tt class="docutils literal"><span class="pre">~/.zshrc</span></tt>.  So I made <a class="reference external" href="https://github.com/joepvd/zsh-hints">zsh-hints</a>, a small helper program that turns a definition file into helpful hints.</p>
<p>Who can remember all those <a class="reference external" href="http://zsh.sourceforge.net/Doc/Release/Expansion.html#Glob-Operators">glob flags</a>?  Imagine wanting to see the Setgid, and world readable files in somewhere here in a subdirectory. Just hit <tt class="docutils literal">&lt;CTRL <span class="pre">X&gt;&lt;g&gt;</span></tt> …</p>
<pre class="code sh literal-block">
% print -l **/*&lt;CTRL X&gt;&lt;g&gt;
</pre>
<p>… and you will be presented with this result:</p>
<pre class="code sh literal-block">
% print -l **/*
/           ▶ directories
F           ▶ non-empty directories <span class="o">(</span>full<span class="o">)</span>
.           ▶ plain files
-           ▶ executable plain files
l<span class="o">[</span>-+<span class="o">]</span>n      ▶ link count
r,w,x       ▶ owner <span class="o">(</span>r<span class="o">)</span>eadable <span class="o">(</span>w<span class="o">)</span>ritable,
              e<span class="o">(</span>x<span class="o">)</span>ecutable files
A,I,E       ▶ group re<span class="o">(</span>A<span class="o">)</span>dable wr<span class="o">(</span>I<span class="o">)</span>table,
              <span class="o">(</span>E<span class="o">)</span>xecutable files
R,W,X       ▶ world <span class="o">(</span>R<span class="o">)</span>readable, <span class="o">(</span>W<span class="o">)</span>ritable,
              e<span class="o">(</span>X<span class="o">)</span>ecutable files
s,G,t       ▶ setuid, setgid, sticky bit files
f<span class="o">[</span>+<span class="o">=</span>-<span class="o">]</span>NNN   ▶ files with access rights matching
              +,-,<span class="o">=</span> octal number
<span class="o">{</span>U,G<span class="o">}</span>NNN    ▶ owned by effective <span class="o">(</span>U<span class="o">)</span>ser,<span class="o">(</span>G<span class="o">)</span>roup
              ID
<span class="o">{</span>u,g<span class="o">}</span>NNN    ▶ owned by user, group id <span class="sb">`</span>NNN<span class="sb">`</span>
<span class="o">{</span>u,g<span class="o">}</span>:name: ▶ owned by user, group name <span class="sb">`</span>name<span class="sb">`</span>
   ...18 hints omitted.
</pre>
<p>A quick glance will help you conclude that <tt class="docutils literal">(.sW)</tt> is what you are looking for.</p>
<p>This example was made on a rather small terminal.  That is why some of the explanations were wrapped, and were displayed with a secondary separator of just a space. It also did not fit in the vertical direction.  An optional message notifying how much you are missing on is displayed.</p>
<p>The key file is really simple to make: It just assumes that the first space separates the key from the explanation. There is no way of putting a space in the key.</p>
<p>All the details of installation and configuration are covered in the <a class="reference external" href="https://github.com/joepvd/zsh-hints">README</a>. Please let me know if it does or does not work for you.</p>
<p>Enjoy :)</p>

        </article>
        
        <article>
          <a class="title" href="http://joepvd.github.io/revisiting-array-to-quote.html">
            <h2>Revisiting array-to-quote</h2>
            <p class=sub-header>
              joepd, 15 April 2014
            </p>
          </a> <!-- /"article-title --> 
          <p>Computing professionals are in some way similar to athletes and musicians: Continued practicing sessions makes them better at what they do.  Interestingly, it seems that there is not so much a culture of inconsequential coding sessions to sharpen your skills.  Dave Thomas practices what he preaches with <a class="reference external" href="http://codekata.com">Code kata</a>'s.</p>
<p>The nice part about repetitive tasks, is that there is a reason to automate 'em.  And when the automated solution starts to feel like a drag, it's time to improve the solution.  Repetitive tasks lend themselves very well to katas.  You probably know the corner cases, and have some ideas of what would suit your work flow.  Continued study of the mechanics of simple manipulations really can get you forward.  As an addition to the metaphor of kata's, I'd like to propose to think about the wood worker sharpening his tools.</p>
<p>That was more than enough meta for an introduction to pretty down-to-earth stuff.  As I regularly have to shape one output in a quoted, comma separated list, I came to revisit the solution posted in my <a class="reference external" href="http://joepvd.github.io/parameter-expansion-in-zsh.html">first post</a>.  This time, I set myself to make a keyboard shortcut that operates on the closest word to the cursor in a terminal running zsh.</p>
<p>Just drop this part in your <tt class="docutils literal"><span class="pre">~/.zshrc</span></tt>, and you should have that short moment of gratification when it seems that the computer is obeying your will at the gentlest of gestures:</p>
<pre class="code sh literal-block">
array-to-quote<span class="o">()</span> <span class="o">{</span>
    autoload -U modify-current-argument
    modify-current-argument <span class="s1">'$(
        if [[ ${(Pt)ARG} = &quot;array&quot; ]]; then
            print ${(j., .)${(qq)${(P)ARG}}}
        elif [[ -r $ARG ]]; then
            print ${(j., .)${(qq)${(f)&quot;$(&lt;$ARG)&quot;}}}
        else
            print ${(qq)ARG}
        fi
    )'</span>
<span class="o">}</span>
zle -N array-to-quote
<span class="c"># Terminal: Stop stealing CTRL-q and CTRL-s!
</span>stty start <span class="s1">'^-'</span> stop <span class="s1">'^-'</span>
bindkey <span class="s2">&quot;^q&quot;</span> array-to-quote
</pre>
<p>If you copy-paste this into your zsh, and press <tt class="docutils literal"><span class="pre">CTRL-q</span></tt>, the word under your cursor will become quoted. If that word happens to be a file, the lines of that file will appear as a quoted list.  If the word i an array, the elements are added nicely quoted and comma separated.  Nice huh?</p>
<p>So, what is actually happening in these few lines?</p>
<p>First, a function is defined, that uses a function usually distributed with <tt class="docutils literal">zsh</tt>: <tt class="docutils literal"><span class="pre">modify-current-argument</span></tt>.  This function takes a function as an argument, and as a bonus, this function can use the variable <tt class="docutils literal">$ARG</tt>: the word under or left of the cursor.  Have a look at <tt class="docutils literal">man zshcontrib</tt> for a complete description.</p>
<p>The function that <tt class="docutils literal"><span class="pre">modify-current-argument</span></tt> calls, make use of parameter expansion flags, and you should be able to follow along after reading my earlier post on the topic.</p>
<p>Now we have a function that takes the word under the cursor as an argument.  This we need to have as a keyboard shortcut.  <tt class="docutils literal">zle <span class="pre">-N</span> <span class="pre">function-name</span></tt> does the first part: It makes the function <tt class="docutils literal"><span class="pre">function-name</span></tt> availabe as a command line editing <strong>widget</strong>.  This widget is in turn bound to <tt class="docutils literal">CTRL q</tt> with the <tt class="docutils literal">bindkey</tt> statement.  There happened to be something special about <tt class="docutils literal"><span class="pre">CTRL-Q</span></tt>:  I needed to tell the terminal driver to not listen to a functionality that I have never knowingly used with the <tt class="docutils literal">stty</tt>-command.  Please tell me if I miss out on cool stuff...</p>
<p>But wait a sec.  There is this other thing that I regularly do:  To make a regular expression from some kind of list.  This is what does that trick, and binds it under <tt class="docutils literal">CTRL \</tt>:</p>
<pre class="code sh literal-block">
array-to-pipe<span class="o">()</span> <span class="o">{</span>
    autoload -U modify-current-argument
    modify-current-argument <span class="s1">'$(
        if [[ ${(Pt)ARG} = &quot;array&quot; ]]; then
            print ${(j.|.)${(P)ARG}}
        elif [[ -r $ARG ]]; then
            print ${(j.|.)${(f)&quot;$(&lt;$ARG)&quot;}}
        else
            print ${ARG}
        fi
    )'</span>
<span class="o">}</span>
zle -N array-to-pipe
bindkey <span class="err">'</span>^<span class="se">\'</span> array-to-pipe
</pre>
<p>Keep sharpening your knives :)</p>

        </article>
        
        <article>
          <a class="title" href="http://joepvd.github.io/readline-and-psql.html">
            <h2>readline and psql</h2>
            <p class=sub-header>
              joepd, 31 December 2013
            </p>
          </a> <!-- /"article-title --> 
          <p>One of the nicer feautures of PostgresQL is its client: psql.  This nifty console application has builtin readline support.  As I am spending so much time in psql sessions, it is worth to learn how to abuse the readline library for some key board magic.</p>
<p>Readline is what you are actually working with (or against!) in an interactive Bash session. ZSH has its own infrastructure for interaction, but there are quite some applications besides Bash which make use of this interaction infrastructure.  A basic list of readline keyboard shortcuts has been compiled at <a class="reference external" href="http://www.bigsmoke.us/readline/shortcuts">this page</a>, and most of these will be in the muscle memory of console warriors.  Suffice to say that this is just a part of the default configuration, see <tt class="docutils literal">man 3 readline</tt> for some more possibilities.</p>
<p>If you find that you are typing often the same thing in a readline supported application, you might be interested to hear that Readline kindly offers to do the typing for you.   These are called keyboard macros, and are configured in readline's configuration file: <tt class="docutils literal"><span class="pre">~/.inputrc</span></tt>.</p>
<p>The following is very useful, almost taken directly from <tt class="docutils literal">man 3 readline</tt>. If you put this in <tt class="docutils literal"><span class="pre">~/.inputrc</span></tt>, pressing <tt class="docutils literal"><span class="pre">Alt-q</span></tt> will put single quotes around the word currently under the cursor:</p>
<pre class="code sh literal-block">
<span class="s2">&quot;^[q&quot;</span>: <span class="s2">&quot;^[b\'^[f\'&quot;</span>
</pre>
<p>This looks cryptic, so let's have a closer look.  Before <tt class="docutils literal">:</tt> is the key combination that triggers the action after the colon. <tt class="docutils literal">^[q</tt> translates into <tt class="docutils literal"><span class="pre">Alt-q</span></tt>, so that will trigger the action.</p>
<p>But how do you know that <tt class="docutils literal">^[q</tt> happens to represent <tt class="docutils literal"><span class="pre">Alt-q</span></tt>?  The good news is that you don't, when you use the following method in <tt class="docutils literal">vim</tt> to generate the escape code.  In insert mode, press <tt class="docutils literal"><span class="pre">CTRL-V</span></tt>. This will tell vim to put literally what comes next.  If you press <tt class="docutils literal"><span class="pre">Alt-q</span></tt> directly after <tt class="docutils literal"><span class="pre">CTRL-v</span></tt>, this sequence will show up, and that is all there is to it.  You will notice, that when moving the cursor over the <tt class="docutils literal">^[</tt>, the cursor will jump over the two signs as if it is one.  That is because it _is_ one character.  Copy pasting these escape sequences into your editor most likely will not work.</p>
<p>So what about the action after the colon? This is a sequence that you can type literally in <tt class="docutils literal">psql</tt>.  Press <tt class="docutils literal"><span class="pre">Alt-b</span></tt> (bound to <tt class="docutils literal"><span class="pre">backward-word</span></tt>), then type a single quote (which in <tt class="docutils literal"><span class="pre">~/.inputrc</span></tt> needs to be escaped by a backslash).  Continue by pressing <tt class="docutils literal">Alt+f</tt>, which brings you to the end of the word, where another single quote is inserted.  Result:  The current word is quoted.  With this configuration in place, you just need to press one key combination, instead of needing complicated eye-hand coordination to move cursor to where it should be.</p>
<p>As I am working with a horribly normalized datamodel where finding what one needs can take an icredible amount of time, I often query the system tables from postgres to navigate in the database.  A question that I keep repeating to ask, is: In which tables does this column name appear? A valuable indicator for the role of the table is the amount of information it contains.  The following query helps me a lot to quickly find what I am actually looking for:</p>
<pre class="code sql literal-block">
<span class="k">select</span> <span class="k">distinct</span>
    <span class="n">relname</span> <span class="k">as</span> <span class="k">table</span><span class="p">,</span>
    <span class="n">reltuples</span> <span class="k">as</span> <span class="n">rowcount</span>
<span class="k">from</span> <span class="n">information_schema</span><span class="p">.</span><span class="n">columns</span> <span class="k">as</span> <span class="n">cols</span>
<span class="k">join</span> <span class="n">pg_class</span> <span class="k">on</span> <span class="n">pg_class</span><span class="p">.</span><span class="n">relname</span> <span class="o">=</span> <span class="n">cols</span><span class="p">.</span><span class="k">table_name</span>
<span class="k">where</span> <span class="k">column_name</span> <span class="o">=</span> <span class="s1">'name-of-column'</span>
    <span class="k">and</span> <span class="n">reltuples</span> <span class="o">&gt;</span> <span class="mi">0</span>
<span class="k">order</span> <span class="k">by</span> <span class="n">reltuples</span><span class="p">;</span>
</pre>
<p>It is a bit of a nuisance to need to edit this text often to enter the column that I am looking for. With the following line, I can type the column on the command line, and after pressing <tt class="docutils literal"><span class="pre">Alt-c</span></tt> (mnemonic: columns), the following happens:</p>
<pre class="code console literal-block">
<span class="go">=&gt; colname&lt;Alt-c&gt;
=&gt; select distinct
-&gt;   relname as table,
-&gt;   reltuples as rowcount
-&gt; from information_schema.columns as cols
-&gt; join pg_class on pg_class.relname = cols.table_name
-&gt; where column_name = 'colname'
-&gt;   and reltuples &gt; 0
-&gt; order by reltuples;
┌─────────────┬──────────┐
│    table    │ rowcount │
├─────────────┼──────────┤
│ table1      │        7 │
│ table2      │       10 │
│ table3      │       22 │
│ table4      │       80 │
│ table5      │      126 │
│ table6      │    13460 │
│ table7      │    50112 │
└─────────────┴──────────┘
(7 rows)</span>
</pre>
<p>The following, admittedly very ugly, line in <tt class="docutils literal"><span class="pre">~/.,inputc</span></tt> makes this possible:</p>
<div class="highlight"><pre><span class="s2">&quot;^[c&quot;</span>: <span class="s2">&quot;\C-a\C-kselect distinct\n  relname as table,\n  reltuples as rowcount \nfrom information_schema.columns as cols \njoin pg_class on pg_class.relname = cols.table_name \nwhere column_name = &#39;\C-y&#39;\n  and reltuples &gt; 0 \norder by reltuples;\n&quot;</span>
</pre></div>
<dl class="docutils">
<dt>CTRL+a:</dt>
<dd>The cursor is moved to the start of the line.</dd>
<dt>CTRL+k:</dt>
<dd>Everything starting from the cursor until the end of the line is killed, or deleted and stored in the kill buffer.</dd>
</dl>
<p>Then, a lot of typing happens, including newlines, and some spacing. Until just after the first quote.</p>
<dl class="docutils">
<dt>CTRL+y:</dt>
<dd>The contents of the kill buffer is yanked in place</dd>
</dl>
<p>...and some conluding typing happens.</p>
<p>This keyboard shortcut does not make a lot of sense in any other program than <tt class="docutils literal">psql</tt>. Luckily, you can select the program for which this shortcut is available by encapsulating the configuration as follows:</p>
<pre class="code sh literal-block">
<span class="nv">$if</span> psql
    <span class="c"># some configuration
</span><span class="nv">$endif</span>
</pre>
<p>This way, you can reprogram all your keys, including function keys!, to do something useful.</p>

        </article>
        
        <article>
          <a class="title" href="http://joepvd.github.io/less-a-love-story.html">
            <h2>less: a love story</h2>
            <p class=sub-header>
              joepd, 27 December 2013
            </p>
          </a> <!-- /"article-title --> 
          <p>Less. I use it more and more.  I would not be surprised if at least a fourth of my time in a console window actually is spent within less.  It is just a pager, you say?  True, but one that has been in <a class="reference external" href="http://www.greenwoodsoftware.com/less/index.html">active development</a> since 1983. The original developer currently is still the maintainer.  You don't need to be an experimental archeologist to put this tool to use. Getting acquainted to this pager will pay itself off pretty fast.</p>
<p>If you haven't done so yet, have a look at <tt class="docutils literal">man 1 less</tt>. The synopsis looks like Sesamestreet episode with brain damage:</p>
<pre class="code sh literal-block">
less <span class="o">[</span>-<span class="o">[</span>+<span class="o">]</span>aABcCdeEfFgGiIJKLmMnNqQrRsSuUVwWX~<span class="o">]</span>
</pre>
<p>It might appear that this overabundance of seemingly unneeded features could serve as a practical definition of bloatware.  These are just the options without arguments. Most of the same options can be used from within the application itself. Once you notice that you like some options, you can make those default.  There are some true gems hidden in the following alphabet soup from the synopsis. I will show which ones I regularly use, but only after having a close look at the searching capabilities of less.</p>
<p>Effective use of less implies that one can use its searching possibilities.  Striking the <tt class="docutils literal">/</tt> initiates a search, and <tt class="docutils literal">enter</tt> concludes it.  Use <tt class="docutils literal">n</tt> to go to the next match, <tt class="docutils literal">N</tt> for the previous.  Searching backward is started off with <tt class="docutils literal">?</tt>.</p>
<p>Search handles by default regular expressions.  With some terminal escape codes set up, less will highlight the matches.  I often type a string like this as a make-shift highlighter:</p>
<pre class="code sh literal-block">
/someID<span class="o">=[</span>0-9<span class="o">]</span>+|error|<span class="o">(</span>STATE|button<span class="o">)</span>.*<span class="err">$</span>
</pre>
<p>Less stores the searches in <tt class="docutils literal"><span class="pre">~/.lesshist</span></tt>, or in any file indicated by the environment variable <tt class="docutils literal">$LESSHISTFILE</tt>.  After starting typing <tt class="docutils literal">/</tt>, the up and down arrows are available to use previous searches.</p>
<p>A search can also be started from the shell.  When I already know what to look for, I often use this, also to leave traces of what I am interested in in the shell history.  Chances are that I already used this search term in the shell, or will in the near future.  Next to helping myself to use zsh's history completion feature, this has proven to be a real time saver when I need to revisit the same problem again.  A typical use is when I want to know what happened at a specific time:</p>
<pre class="code console literal-block">
<span class="gp">%</span> less +/^16:34 logfile
</pre>
<p>This will open the file, and jump immediately to the first line with that time stamp.  Less will also store this search in its history file.  Unfortunatelty, there is no mechanism to search the past searches.</p>
<p>The most recent search term has a special role when pressing <tt class="docutils literal"><span class="pre">ESC-F</span></tt>.  New content of the file will be displayed as with <tt class="docutils literal">tail <span class="pre">-f</span></tt> or the normal <tt class="docutils literal">F</tt>-function, but the scrolling will stop with the first match of the most recent search.</p>
<p>A lesser known search facility is the one initiated by <tt class="docutils literal">&amp;</tt>. This filters the output to just the matching lines.  I use this often when looking at the output of some command:  One can refrain from running the command again only to use grep to find the interesting lines.  A renewed search is done on the whole output, so one cannot apply a filter on a filter.  Specifying lines that do not match the expression (<tt class="docutils literal">grep <span class="pre">-v</span></tt>), can be initiated by typing <tt class="docutils literal">&amp;!</tt>.  After having refined the search pattern, the result can be saved with <tt class="docutils literal">s filename</tt>.</p>
<p>The <tt class="docutils literal">&amp;</tt>-filter interacts with the search history.  As I regularly have to dig in a logfiles where the first encounter is really helped by such a filter, I set up an alias like this:</p>
<pre class="code sh literal-block">
<span class="nb">alias </span><span class="nv">lf</span><span class="o">=</span><span class="s2">&quot;less +$'&amp;event1|action2|state3|error\n' &quot;</span>
</pre>
<p>With this less-filter I can quickly get a birds eye perspective on the events.  The filter can be disabled by an empty filter, so by pressing <tt class="docutils literal">&amp;[enter]</tt>. and can easily zoom in, and have this search string ready for poor man's highlighting.  A quick <tt class="docutils literal"><span class="pre">-N</span></tt> to display line numbers, and typing the number of where I want to start to look, followed by <tt class="docutils literal">g</tt>, brings me immediately to where I want to be.</p>
<p>When less is running, the following keys I use most:</p>
<dl class="docutils">
<dt>G</dt>
<dd>Go to end of file. Before that, check if the file has changed. Great for viewing log files.</dd>
<dt>g</dt>
<dd>Go to beginning of file, or, when a number is pressed first, go to that line number.</dd>
<dt>ESC-u</dt>
<dd>Undo search highlighting.</dd>
<dt>F</dt>
<dd>Follow file. It's like <tt class="docutils literal">tail <span class="pre">-f</span></tt>, but after the BREAK signal (CTRL+c), all the niceties of the pager are still intact.  And: <tt class="docutils literal">tail <span class="pre">-f</span></tt> cannot do the line wrapping.</dd>
<dt>Number%</dt>
<dd>Type in <tt class="docutils literal">50%</tt>, and you'll see the middle of the file.</dd>
<dt>-S[Enter]</dt>
<dd>Toggle line wrapping.</dd>
<dt>-i[Enter]</dt>
<dd>Toggle case insensitive search.</dd>
<dt>-N and -n</dt>
<dd>Enable and disable line numbers.</dd>
</dl>
<p>Despite the numerous options, I am not using so much more in my day to day usage of less.  Some options can be specified on the command line.  The following I consider nice:</p>
<dl class="docutils">
<dt>-R</dt>
<dd>For when the file contains raw characters, for example ANSI color codes. This causes less not to choke on colored output, or to see the garbage in a binary file, instead of an error message.</dd>
<dt>-X</dt>
<dd><p class="first">This causes the screen not to be repainted after less exits. After viewing a file or man-page, I find it increadibly useful to be able to see the last screen in my terminal emulator's scroll back window.  Just make the part visible that is of interest, and you have the reference visible when typing your command.  In most terminal emulators, Shift+PgUp/PgDown gets the relevant info back again.</p>
<p>This setting makes most sense when the output is not too long, or if you know you'll be able to get to the important points in few jumps.  To disable this feature, use <tt class="docutils literal"><span class="pre">-+X</span></tt> as an option.</p>
<p class="last">It is unfortunate that everything that has been displayed in less is retained in the scrollback. It would be more convenient to only have a screen full of output in the console, especially when needing to browse insane amounts of text.  I have not yet managed to fix this.</p>
</dd>
<dt>-M</dt>
<dd>Get a long prompt in less. Useful info about filename, length of file, and current position.</dd>
</dl>
<p>To have less always use the same options that you like, it listens to the <tt class="docutils literal">$LESS</tt> environment variable in your <tt class="docutils literal"><span class="pre">~/.bashrc</span></tt> or <tt class="docutils literal"><span class="pre">$ZDOTDIR/.zshrc</span></tt>.  I have set mine to the following:</p>
<pre class="code sh literal-block">
<span class="nb">export </span><span class="nv">LESS</span><span class="o">=</span><span class="s1">'MSRiX'</span>
</pre>
<p>These letters have the following effect: long prompt, chop long lines, raw, case insensitive search, keep output in scrollback buffer.</p>
<p>Possibly, your distribution, or you yourself, has set up some nice colors to display different colors in man-pages.  I have the following escape codes somewhere in the startup files of my shell:</p>
<pre class="code sh literal-block">
<span class="nb">export </span><span class="nv">LESS_TERMCAP_mb</span><span class="o">=</span><span class="s1">$'\e[01;31m'</span>       <span class="c"># begin blinking
</span><span class="nb">export </span><span class="nv">LESS_TERMCAP_md</span><span class="o">=</span><span class="s1">$'\e[01;38;5;74m'</span>  <span class="c"># begin bold
</span><span class="nb">export </span><span class="nv">LESS_TERMCAP_me</span><span class="o">=</span><span class="s1">$'\e[0m'</span>           <span class="c"># end mode
</span><span class="nb">export </span><span class="nv">LESS_TERMCAP_so</span><span class="o">=</span><span class="s1">$'\e[38;5;070m'</span>    <span class="c"># begin standout (info box, search)
</span><span class="nb">export </span><span class="nv">LESS_TERMCAP_se</span><span class="o">=</span><span class="s1">$'\e[0m'</span>           <span class="c"># end standout-mode
</span><span class="nb">export </span><span class="nv">LESS_TERMCAP_us</span><span class="o">=</span><span class="s1">$'\e[04;38;5;146m'</span> <span class="c"># begin underline
</span><span class="nb">export </span><span class="nv">LESS_TERMCAP_ue</span><span class="o">=</span><span class="s1">$'\e[0m'</span>           <span class="c"># end underline
</span><span class="nb">export </span><span class="nv">MAN_KEEP_FORMATTING</span><span class="o">=</span>1
</pre>
<p>The last entry might not be clear.  When piping the output of <tt class="docutils literal">man</tt> to less, the colors are not retained. Unless the <tt class="docutils literal">MAN_KEEP_FORMATTING</tt> environment variable has a value.</p>
<p>The same trick I use in Something that I often use if I want to see : <tt class="docutils literal">man less | less <span class="pre">+/'^</span> <span class="pre">*-X'</span></tt>. This jumps directly to the place where <tt class="docutils literal"><span class="pre">-X</span></tt> is in front of a line, possibly with some spaces. Most of the time, it just jumps to the explanation that you want to see, otherwise press <tt class="docutils literal">n</tt> to jump to the next hit.</p>

        </article>
        
        <article>
          <a class="title" href="http://joepvd.github.io/parameter-expansion-in-zsh.html">
            <h2>Parameter expansion in zsh</h2>
            <p class=sub-header>
              joepd, 10 December 2013
            </p>
          </a> <!-- /"article-title --> 
          <p>The shell is a high quality text processor, and zsh is especially suited for that purpose.  In this post, I will show some of the tricks I use for an editing problem that I encounter every day.  Concretely: How to quickly generate queries, after receiving a list of IDs.  This is what the result should look like:</p>
<pre class="code sql literal-block">
<span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="k">table</span> <span class="k">where</span> <span class="n">ID</span> <span class="k">in</span> <span class="p">(</span><span class="s1">'1234'</span><span class="p">,</span> <span class="s1">'2345'</span><span class="p">,</span> <span class="s1">'3456'</span><span class="p">);</span>
</pre>
<p>A fast way to achieve this looks thusly:</p>
<pre class="code console literal-block">
<span class="gp">%</span> <span class="nv">ar</span><span class="o">=(</span>
<span class="go">array&gt; 1234
array&gt; 2345
array&gt; 3456
array&gt; )

</span><span class="gp">%</span> print <span class="s2">&quot;select * from table where id in (${(j:, :)${(qq)ar[&#64;]}});&quot;</span>
<span class="go">select * from table where id in ('1234', '2345', '3456');</span>
</pre>
<p>What is happening here? First I am creating an array of something I have available in my paste buffer: I type the name of an array, <cite>=</cite>, and <cite>(</cite>, and press enter. Then I paste a list of IDs, close it off with a <cite>)</cite>. Now the info is available at my fingertips. The second action, the print statement with the hardly memorable parameter expansion, is the main topic of this post.</p>
<p>Shells provide convenience functions to do stuff with parameters, and <cite>zsh</cite> surely is the most advanced in this regard.  These parameter expansions are easiest to read from the inside to the outside, so let's have a look at <tt class="docutils literal"><span class="pre">${(qq)ar[&#64;]}</span></tt>.  This consists of two parts, <tt class="docutils literal"><span class="pre">${ar[&#64;]}</span></tt> and <tt class="docutils literal">(qq)</tt>.</p>
<p>The result of <tt class="docutils literal"><span class="pre">${ar[&#64;]}</span></tt> is into all the elements of array <tt class="docutils literal">ar</tt>.  In any shell that conforms to POSIX, you can specify elements of an array by encapsulating them in square brackets: <tt class="docutils literal">${ar[2]}</tt> would be <tt class="docutils literal">2345</tt>.  One can use the <tt class="docutils literal">&#64;</tt> to say that you want all the indexes.</p>
<p>In <tt class="docutils literal">zsh</tt>, if there is an opening bracket directly after the curly opening bracket, magic is immanent.  The bracketed characters are flags.  For a complete overview of what can be done, see <tt class="docutils literal">man zshexpn | less <span class="pre">+/'^</span> *Parameter Expansion Flags'</tt>. In this case, the members of <tt class="docutils literal">ar</tt> are treated with the action that is hiding behind the <tt class="docutils literal">qq</tt>.  The effect of this flag is quoted with single quotes.  (You can use three q's for double quotes).</p>
<p>So the net result of the inner expansion is a copy of the arrat <tt class="docutils literal">ar</tt>, with the difference that the elements are quoted.  This is the intermediate result what the outer expansion, <tt class="docutils literal"><span class="pre">${(j:,</span> <span class="pre">:)…}</span></tt> is working with.  The flag <tt class="docutils literal">j</tt> is for joining the elements of an array, with whatever is between the colons as a separator, in our case a comma followed by space. The colons are arbitrary: If your join string contains colons itself, you can take a comma or a period, or whatever.</p>
<p>The result is, as you have seen, that <tt class="docutils literal"><span class="pre">${(j:,</span> <span class="pre">:)${(qq)ar[&#64;]}}</span></tt> is expanded to a comma separated line of quoted elements of array <tt class="docutils literal">ar</tt>.  As I use this kind of expansion on a daily basis, and this expansion is a bit too tedious to type in every time, I spent a bit of time to make this expansion available at my finger tips in the form of a shell function <tt class="docutils literal">a2q</tt>:</p>
<pre class="code sh literal-block">
a2q <span class="o">()</span> <span class="o">{</span>
        print <span class="k">${</span><span class="p">(j:, :)</span><span class="k">${</span><span class="p">(Pqq)1</span><span class="k">}</span><span class="p">[&#64;]</span><span class="k">}</span>
<span class="o">}</span>
</pre>
<p>This can be used as follows:</p>
<pre class="code console literal-block">
<span class="gp">%</span> print <span class="s2">&quot;select * from table where id in ($(a2q ar));&quot;</span>
</pre>
<p>Compared to the interactive version, the array is a positional parameter: <tt class="docutils literal">$1</tt> is being expanded, so you can type: <tt class="docutils literal">a2q myarray</tt> to have <tt class="docutils literal">a2q</tt> work on <tt class="docutils literal">myarray</tt>. In order to make this work, an extra trick needed to be added:  The <cite>P</cite>-flag has been added to the inner parameter expansion flags. This makes that the resulting string is considered to be a parameter.</p>
<p>This works great, but it can be generalized.  Sometimes the list of IDs is given as an file.  By virtue of the <cite>f</cite>-flag, the following snippet loads the newline separated contents of file <cite>file</cite> into array <cite>array</cite>:</p>
<pre class="code sh literal-block">
<span class="nv">array</span><span class="o">=(</span> <span class="k">${</span><span class="p">(f)</span><span class="k">$(</span>&lt;file<span class="k">)}</span> <span class="o">)</span>
</pre>
<p>Just to facilitate laziness, the function a2q can be expanded to check what type of argument it got, and based on that, populate a temporary array with infos. Multiple arguments are allowed. If no argument is provided, a2q will listen to STDIN, so you can pipe the output of another command to it. After all the processing, the last step is to print the contents of the array in the desired way:</p>
<pre class="code sh literal-block">
emulate -L zsh
<span class="nb">typeset</span> -U ar
<span class="nv">ar</span><span class="o">=()</span>
_err<span class="o">()</span> <span class="o">{</span>
    <span class="nb">echo</span> <span class="s2">&quot;Do not understand: ${1}&quot;</span> &gt;&amp;2
    <span class="nb">echo</span> <span class="s2">&quot;Arguments need to be files, names of arrays, or standard input.&quot;</span> &gt;&amp;2
    <span class="nb">echo</span> <span class="s1">'Arrays must be referenced by name, so use `array` instead of `$array`.'</span> &gt;&amp;2
    <span class="nb">exit </span>1
<span class="o">}</span>

<span class="k">if</span> <span class="o">[[</span> <span class="nv">$# </span><span class="o">==</span> 0 <span class="o">]]</span>; <span class="k">then</span>
    <span class="c"># Listen to STDIN if no arguments are provided
</span>    <span class="nv">ar</span><span class="o">=(</span> <span class="k">${</span><span class="p">(f)</span><span class="k">$(</span>&lt;&amp;0<span class="k">)}</span> <span class="o">)</span>
<span class="k">fi

while</span> <span class="o">[[</span> <span class="nv">$# </span>&gt; 0 <span class="o">]]</span>; <span class="k">do
    if</span> <span class="o">[[</span> -r <span class="s2">&quot;$1&quot;</span> <span class="o">&amp;&amp;</span> -f <span class="s2">&quot;$1&quot;</span> <span class="o">]]</span>; <span class="k">then</span>
        <span class="c"># A readable file.
</span>        <span class="nv">ar</span><span class="o">=(</span>
            <span class="nv">$ar</span><span class="o">[</span>&#64;<span class="o">]</span>
            <span class="s2">&quot;${(fq)$(&lt;$1)}&quot;</span>
        <span class="o">)</span>
    <span class="k">elif</span> <span class="o">[[</span> <span class="k">${</span><span class="p">(Pt)1</span><span class="k">}</span> <span class="o">=</span> <span class="s2">&quot;array&quot;</span> <span class="o">]]</span>; <span class="k">then
        </span><span class="nv">ar</span><span class="o">=(</span>
            <span class="nv">$ar</span><span class="o">[</span>&#64;<span class="o">]</span>
            <span class="k">${</span><span class="p">(Pq)1</span><span class="k">}</span>
        <span class="o">)</span>
    <span class="k">else
        </span>_err
    <span class="k">fi
    </span><span class="nb">shift
</span><span class="k">done

</span>print <span class="k">${</span><span class="p">(j:, :)</span><span class="k">${</span><span class="p">(qq)ar[&#64;]</span><span class="k">}}</span>
</pre>
<p>I stored the above as <tt class="docutils literal">a2q</tt> in a <a class="reference external" href="http://zsh.sourceforge.net/Doc/Release/Functions.html#Autoloading-Functions">directory whose contents gets autoloaded</a> when required, so I have it available at my finger tips.</p>
<p>Enjoy!</p>

        </article>
        
        <article>
          <a class="title" href="http://joepvd.github.io/about-this-website.html">
            <h2>About this website</h2>
            <p class=sub-header>
              joepd, 09 December 2013
            </p>
          </a> <!-- /"article-title --> 
          <p>Hello world! This is the first post to my site, which will double as the about page.  Yet another site dedicated to consoles, shells, and old school interfaces to solved problems?  Isn't there enough documentation and experience out there to warrant another site?</p>
<p>As with all good questions, the answer is both <em>yes</em> and <em>no</em>.</p>
<p><strong>Yes</strong>.  I proudly want to produce new content as a tribute to all the valuable and intricate pieces of information that have been shared before.  I have learnt an awful lot from excellent people documenting informally how they overcome smaller and bigger technological hurdles while accomplishing stuff.  And I have enjoyed doing so.  A second reason for this resounding yes, is the hope that processes of documenting and publishing trivia, intricacies and insights will assist me in the battle against forgetfulness.</p>
<p>But I fancy to think that also that also <strong>No</strong> is a valid answer:  This site will have a distinctive perspective.  One thing where I find current informal, online documentation lacking, is in the description of <strong>interactive usage</strong> of tools.  Much of the online documentation is a static description of how tools work, whereas how those tools can be used efficiently in a work flow of analyzing and fixing problems.  If this were a blog about cooking, I would try to refrain from showing the ingredients and knives, and rather focus on how to cut and fry an onion to acchieve different results.</p>
<p>I have a fetish for basic tools.  Be it a sharp knife in the kitchen, or the precise power tools that the One Thing Well software philosophy has brought about.  The process of interactive discovery of the real problem is where the flexibility of the software tool philosophy really shines.  In this blog I hope to provide some useful perspectives, approaches and recipes about the intersection of basic tools and work flows.</p>
<p>This site is statically generated with <a class="reference external" href="http://getpelican.com">Pelican</a>, and I don't feel the need to take care of comments.  I do not want to imply that I do not like feed back, but prefer to get spam in my mail box rather than on the public net that I need to maintain.  For now, for praise and bug reports, you can reach me best over email. I am sure you can puzzle my address together from the following bits of information:</p>
<p>user: escape-code
host: xs4all
tld: nl</p>
<p>Enjoy reading!</p>

        </article>
  </section>

    <footer>
      <address id="about" class="vcard body">
        Powered by <a href="http://getpelican.com/">Pelican</a>. 
      </address><!-- /#about -->

      <p>
      All rights reserved. All wrongs reversed. All is released in the public
      domain. 
      </p>
    </footer>
  </body>
</html>